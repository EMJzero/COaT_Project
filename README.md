# COaT_Project 2023
Project for the Code Optimization and Transformation course 2023 - integrate TAFFO and PandA-Bambu.

## Goal

Perform the HLS (High Level Synthesis) of programs that have first had their floating point operations optimized in fixed point ones with the aid of TAFFO. The HLS part is instead done via PandA-Bambu. <br>
See the following links for infomation regarding the two tools:
- TAFFO: https://github.com/TAFFO-org/TAFFO
- PandA-Bambu: https://github.com/ferrandi/PandA-bambu

## Overview

Currently the repository contains various test cases revolving around floating point operations. Some of the tests originate from examples provided by either TAFFO or PandA-Bambu, as can be understood from their names.

### Folder organization

In each folder there are mainly of following files:
- **test.c**: The code for the test, the target of the HLS is always the function invoked by main whose name coincides with the test's one;
- **test.ll**: The LLVM-IR representation of **test.c** obtained with TAFFO, usually with the value names preserved for readability;
- **test_*.c**: Variants of **test.c** used to explore different behaviours of tools;
- **test.xml**: Contains the values for PandA-Bambu's simulations, note that for when the HLS starts from an LLVM-IR parameter names are in the form `PdN` with N realtive to the IR without preserved names. The same **test.xml** contains also the values for when the HLS is conducted directly from the source, and those share the name of the source's parameters.
- **test_generator.py**: Python script used to generate **test.xml**'s content.
- **results_opt.txt**: Report generated by PandA-Bambu after the simulation of the generated design, the first column's **1**-s indicate a successful simulation, while the second column reports the number of clock cycles the simulation took to complete. Those specifically are the results for the code **optimized with TAFFO**;
- **results.txt**: Same as **results_opt.txt** but contains the results for the code **without utilizing TAFFO**;
- **notes.txt**: Report regarding the status of the test, containing also additional comments or procedures used to perform the test;

In some cases there are subfolders within a test's folder, those recursively mirror the same structure detailed above and their purpose is to separate the results and HLS output for slightly different versions of the test.

### The tests

Here is the current list of tests:

- **ComputePi**: Computes Pi with the Madhava-Leibniz formula (https://en.wikipedia.org/wiki/Leibniz_formula_for_pi);
- **ComputeSinCos**: Computes $sin(\pi/12)$ and $cos(\pi/6)$ via the Taylor expansion of Cosine (https://en.wikipedia.org/wiki/Taylor_series);
- **ComputeSqrt**: Compute the Square root of a provided number with the Newton-Raphson method (https://en.wikipedia.org/wiki/Newton%27s_method);
- **FromPanda_fft_float**: Fast Furier Transfom example from here https://github.com/ferrandi/PandA-bambu/tree/dev/panda/examples/fft_example;
- **FromPanda_mm_float**: Matrix multiplication example from here https://github.com/ferrandi/PandA-bambu/tree/dev/panda/examples/mm_float;
- **FromPanda_mm_float_inside_opt**: Variant of **FromPanda_mm_float** made specifically to synthesize the floating point to fixed point coversions;
- **FromTaffo_axbench_fft**: Fast Furier Transfom example from here https://github.com/TAFFO-org/TAFFO/tree/master/test/axbench/fft;
- **FromTaffo_axbench_inversek2j**: Forward and inverse kinematics example from here https://github.com/TAFFO-org/TAFFO/tree/master/test/axbench/inversek2j;
- **FromTaffo_fpbench_CX**: Example from here https://github.com/TAFFO-org/TAFFO/tree/master/test/fpbench/CX;
- **FromTaffo_test3**: Example from here https://github.com/TAFFO-org/TAFFO/blob/master/test/simple-test-cases/test3.c;
- **NormalizeVector**: Transforms a vector to have a unitary norm (Uses `math.h`'s `sqrtf` function);
- **SimpleTaffoTest**: A few trivial tests to verify that TAFFO and PandA-Bambu are working properly;

Currently not all test are workig all the way through TAFFO, HLS and simulation, refer to the **notes.txt** files for the details of each test.

### Results

A major decision to be made during the process is where to place the floating point to fixed point conversion. Since generating appropriate test values and verifying test results with the conversion **not** synthesized proved challenging (I am still exploring this possibility), note that **all the following results and those in the repository assume that the conversion is synthesied** and the I/O of with the design is performed with floating point values. 

The latest comprehensive list of measured performance metrics on the various test can be reviewed here:<br>
[--> link to the excel document <--](https://polimi365-my.sharepoint.com/:x:/g/personal/10669641_polimi_it/EQ8R5ElhK_BKmf_rSk1-DioBY5HdXF9fdG_eAb6Fkf4CdQ?e=v3GLxB)

## Procedures

Here are the main commands used to generate the LLVM-IR, run the HLS and the simulations.

- Produce the LLVM-IR optimized with TAFFO:<br>
    `taffo -fno-discard-value-names -S -emit-llvm -o test.ll test.c`<br>
    Add the `-lm` option if `math.h` needs to be linked.
- Run the HLS on TAFFO's produced LLVM-IR:<br>
    `bambu-2023.1.AppImage test.ll --use-raw -v 2 --top-fname=<function_name_wrt_the_IR> --compiler=I386_CLANG12 --simulate --simulator=VERILATOR`<br>
    To specify a target device for later synthesis use `--device-name=<name>`.<br>
    To see the input and output of each simulation use an higher log verbosity: `-v 4`<br>
    Add the `-lm -ffast-math --libm-std-rounding` options if `math.h` needs to be linked.<br>
    ~~Also consider using `-fsingle-precision-constant -Os --experimental-setup=BAMBU`.~~
- Run the HLS on the original code:<br>
    `bambu-2023.1.AppImage test.c -v 2 --top-fname=<function_name_wrt_the_sourcecode> --compiler=I386_CLANG12 --simulate --simulator=VERILATOR`<br>
    Add the `-lm -ffast-math --libm-std-rounding` options if `math.h` needs to be linked.
- Generate new testbench values:<br>
    `python3 test_generator.py <args> > test.xml`<br>
    Different generators might require some command-line arguments.